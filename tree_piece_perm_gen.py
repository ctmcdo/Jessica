import itertools as it
import math
import numpy as np

FR_CASES = [[2, 2, 2, 1], [2, 2, 1, 1], [2, 2, 1, 0]]

# TODO: better comment. Remember that ignore 2s is key to this formula
# sum_{i=1}^{4}(i + 1) = 14
NUM_COVERED_SETS = 14
FIXED_ROOK_SCENARIOS = 3
NUM_PIECE_TYPES_LESS_KING = 4
MAX_OF_ANY_ONE_BASE_PIECE = 2

# (2, 2, 1, 0) gives rise to permutation with greatest cost: (1, 0, 2, 2)
# which is base cost + 3. There are also base + 1, base + 2, ... so 4 in total
NUM_UNIQUE_PERM_COSTS = 4

INDICES_SHAPE = (
    FIXED_ROOK_SCENARIOS,
    MAX_OF_ANY_ONE_BASE_PIECE + 1,
    MAX_OF_ANY_ONE_BASE_PIECE + 1,
    MAX_OF_ANY_ONE_BASE_PIECE + 1,
    MAX_OF_ANY_ONE_BASE_PIECE + 1,
)
PERMS_SHAPE = (
    FIXED_ROOK_SCENARIOS,
    NUM_COVERED_SETS,
    math.factorial(NUM_PIECE_TYPES_LESS_KING),
    NUM_PIECE_TYPES_LESS_KING,
)
COST_BOUNDARIES_SHAPE = (
    FIXED_ROOK_SCENARIOS,
    NUM_COVERED_SETS,
    NUM_UNIQUE_PERM_COSTS,
)

fr_coveredSet_indices = np.negative(np.ones(INDICES_SHAPE, np.int32))
fr_coveredSet_perms = np.negative(np.ones(PERMS_SHAPE, np.int32))
fr_coveredSet_perm_cost_boundaries = np.negative(
    np.ones(COST_BOUNDARIES_SHAPE, np.int32)
)


def covered_sets(fr_case_num):
    b = FR_CASES[fr_case_num]
    s = b.copy()

    cset_num = 0
    fr_coveredSet_indices[fr_case_num][s[0]][s[1]][s[2]][s[3]] = cset_num
    yield s, 0

    cset_num += 1
    while s[0] != 0:
        for i in range(NUM_PIECE_TYPES_LESS_KING - 1, -1, -1):
            if s[i] != 0:
                s[i] -= 1
                for j in range(i + 1, NUM_PIECE_TYPES_LESS_KING):
                    s[j] = min(s[i], b[j])

                fr_coveredSet_indices[fr_case_num][s[0]][s[1]][s[2]][s[3]] = cset_num
                yield s, cset_num

                cset_num += 1
                break


def cost(s, b):
    c = 0
    for i in range(NUM_PIECE_TYPES_LESS_KING):
        diff = s[i] - b[i]
        if diff > 0:
            c += diff
    return c


def c_arr_literal_str_helper(a, depth):
    s = "{"
    if len(a.shape) == 1:
        for i in range(a.shape[0] - 1):
            s += str(a[i]) + ", "
        s += str(a[a.shape[0] - 1])
    else:
        for i in range(a.shape[0]):
            s += c_arr_literal_str_helper(a[i], depth + 1)
    s += "}"
    if depth != 0:
        s += ", "
    return s


def c_arr_literal_str(a):
    return c_arr_literal_str_helper(a, 0)


def c_dimensions_str(shape):
    s = ""
    for dim in shape:
        s += "[" + str(dim) + "]"
    return s


def format_c_arr_str(a, npname):
    s = "char "
    s += npname
    s += c_dimensions_str(np.shape(a))
    s += " = "
    s += c_arr_literal_str(a)
    s += ";"
    return s


for i in range(FIXED_ROOK_SCENARIOS):
    for (s, cset_num) in covered_sets(i):
        cost_to_perms = {}
        for p in it.permutations((0, 1, 2, 3)):
            permuted_set = [s[pe] for pe in p]
            c = cost(permuted_set, FR_CASES[i])
            if c not in cost_to_perms:
                cost_to_perms[c] = []
            else:
                cost_to_perms[c].append(tuple(p))
        c = 0
        pi = 0
        for c, perms in sorted(cost_to_perms.items()):
            for e in perms:
                for j in range(NUM_PIECE_TYPES_LESS_KING):
                    fr_coveredSet_perms[i][cset_num][pi][j] = e[j]
                pi += 1

            fr_coveredSet_perm_cost_boundaries[i][cset_num][c] = pi

        to_be_copied = fr_coveredSet_perm_cost_boundaries[i][cset_num][c]
        for j in range(c + 1, NUM_UNIQUE_PERM_COSTS):
            fr_coveredSet_perm_cost_boundaries[i][cset_num][j] = to_be_copied


f = open("tree_piece_perm.c", "w")
f.write("// Generated by gen_prom_perms.py.\n")
f.write("// Formatted by clang thereafter\n\n")
f.write('#include "tree_common.h"\n\n')
f.write(format_c_arr_str(fr_coveredSet_indices, "fr_coveredSet_indices"))
f.write("\n")
f.write(format_c_arr_str(fr_coveredSet_perms, "fr_coveredSet_perms"))
f.write("\n")
f.write(
    format_c_arr_str(
        fr_coveredSet_perm_cost_boundaries, "fr_coveredSet_perm_cost_boundaries"
    )
)
